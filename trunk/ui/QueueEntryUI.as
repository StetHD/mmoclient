package ui {		import flash.display.MovieClip;	import fl.text.TLFTextField;		import game.Contract;	import game.Building;	import game.entity.City;		import QueueProgressIcon;	import game.Assignment;	import game.entity.Improvement;	import flash.display.BitmapData;	import flash.display.Bitmap;	import game.Item;	import flash.utils.Timer;	import flash.events.TimerEvent;		public class QueueEntryUI extends MovieClip	{				public static var PROGRESS_START_X:int = 58;		public static var PROGRESS_START_Y:int = 16;		public static var PROGRESS_SPACER_X:int = 2;			public var city:City;			public var queueEntryName:TLFTextField;		public var remainingTimeText:TLFTextField;				private var contract:Contract;				private var timer:Timer;		private var remainingTime:int;				private var secPerIcon:Number = 0;		private var currentSeconds:int = 0;		private var progressIcons:Array = new Array();		private var numProgressIcons:int = 0;				public function QueueEntryUI()		{						timer = new Timer(1000, 0);			timer.addEventListener(TimerEvent.TIMER, timerTick);			timer.addEventListener(TimerEvent.TIMER_COMPLETE, timerComplete);		}				public function setQueueEntry(contract:Contract) : void		{			this.contract = contract;												clearQueueEntry();			setQueueEntryIcon();		}				public function getContract() : Contract		{			return contract;		}			private function setQueueEntryIcon() : void		{			switch(contract.type)			{				case Contract.CONTRACT_BUILDING:					var building:Building = city.getBuildingByType(contract.objectType);					var productionRate:Number = city.getProductionRate(contract.targetId, contract.targetType);										setImage(building.getImage());					setProgressIcons(contract.production, productionRate, building.getProductionCost());					setQueueEntryName(Building.getNameByType(building.type));					setRemainingTime(contract.production, productionRate, building.getProductionCost());										break;						case Contract.CONTRACT_IMPROVEMENT:					var improvement:Improvement = city.getImprovement(contract.targetId);					var productionRate:Number = city.getProductionRate(contract.targetId, contract.targetType);										setImage(improvement.getImage());					setProgressIcons(contract.production, productionRate, improvement.getProductionCost());					setQueueEntryName(improvement.getName());					setRemainingTime(contract.production, productionRate, improvement.getProductionCost());					break;				case Contract.CONTRACT_HARVEST:				case Contract.CONTRACT_ITEM:					var item:Item = new Item();					var productionRate:Number = city.getProductionRate(contract.targetId, contract.targetType);										item.type = contract.objectType;										setImage(item.getImage());					setProgressIcons(contract.production, productionRate, item.getProductionCost());					setQueueEntryName(item.getName());					setRemainingTime(contract.production, productionRate, item.getProductionCost());					break;			}							}				private function setImage(bitmapData:BitmapData) : void		{			var image:Bitmap = 	new Bitmap(bitmapData);			image.x = 0;			image.y = 0;						addChild(image);					}				private function setProgressIcons(currentProduction:Number, progressRate:Number, productionCost:Number) : void		{			trace("currentProduction: " + currentProduction + " productionCost: " + productionCost);			var progressRatio:Number = 0;			var numIcons:int = 10;						if(currentProduction != 0)				 progressRatio = currentProduction / productionCost;									if(progressRate > 0 && progressRatio > 0)			{				var remainingProduction:int = productionCost - currentProduction;				var prodPerIcon:Number = productionCost / numIcons;				secPerIcon = remainingTime / (remainingProduction / prodPerIcon);			}						numProgressIcons = Math.floor(progressRatio * numIcons);						updateProgressIcons(numProgressIcons);		}						private function updateProgressIcons(numProgressIcons:int) : void		{			removeProgressIcons();						for(var i:int = 0; i < numProgressIcons; i++)			{				var progressIcon:MovieClip = new QueueProgressIcon();								progressIcon.x = PROGRESS_START_X + i * (progressIcon.width + PROGRESS_SPACER_X);				progressIcon.y = PROGRESS_START_Y;								addChild(progressIcon);								progressIcons.push(progressIcon);			}							}				private function removeProgressIcons() : void		{			for(var i:int = 0; i < progressIcons.length; i++)			{				if(this.contains(progressIcons[i]))				{					this.removeChild(progressIcons[i]);				}			}		}				private function setQueueEntryName(entryName:String)		{			queueEntryName.text = entryName;		}				private function setRemainingTime(production:int, progressRate:Number, productionCost:int) : void		{						trace("production: " + production + "progressRate: " + progressRate + " productionCost: " + productionCost);					var remainingDays:Number;			var remainingHours:Number;			var remainingSeconds:String;					if(progressRate > 0)			{				var remainingProduction:int = productionCost - production;				remainingTime = Math.round(remainingProduction / progressRate);					remainingSeconds = remainingTime.toString() + "s";								setTimer();			}			else			{				remainingSeconds = "Never";			}						remainingTimeText.text = remainingSeconds;		}				private function setTimer() : void		{			timer.repeatCount = remainingTime;						if(!timer.running)			{								timer.start();			}		}						private function timerTick(e:TimerEvent) : void		{			remainingTime -= 1;			var remainingSeconds:String = remainingTime.toString() + "s";			remainingTimeText.text = remainingSeconds;						currentSeconds++;						if(currentSeconds > secPerIcon)			{				currentSeconds = 0;				numProgressIcons++;				updateProgressIcons(numProgressIcons)			}		}				private function timerComplete(e:TimerEvent) : void		{					}				private function clearQueueEntry() : void		{					}	}	}